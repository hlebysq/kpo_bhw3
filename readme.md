# КР3. Асинхронное межсервисное взаимодействие.
## Выполнил: Золотухин Глеб, БПИ236

### Суть работы серверной части веб-приложения

API должно взаимодействовать со счетами клиентов: создавать, пополнять,
просматривать. Также должна быть возможность создавать заказы, которые 
в дальнейшем в фоновом режиме будут обрабатываться и снимать сумму за
покупку со счета пользователя.

### Начало работы

Была использована следующая архитектура: сервис Api Gateway для 
рутинга запросов, Payment Service для хранения и 
прямого взаимодействия со счетами пользователей, 
Order Service для обработки заказов.

### Важные архитектурные решения

Так как при создании заказа схема "запрос-ответ" неоптимальна
(потому что мы не хотим при создании заказа ожидать завершения 
предыдущего, плюс выполнение заказа может занять ощутимое количество
времени), был выбран асинхронный тип взаимодействия между сервисами. 
Для того, чтобы избежать потери данных при передаче, было принято 
решение использовать брокер сообщений. Из-за небольших масштабов
был выбран брокер сообщений RabbitMQ из-за его простоты и надежности,
при масштабировании проекта, конечно, оптимальнее было бы использовать 
Kafka. По той же причине в проектах используются базы данных SQLite - 
при бОльших масштабах релевантнее былл бы использовать что-то посерьезнее,
вроде Posgtres, но так как это учебный пет проект необходимости в этом нет.

При работе с финансами важна надежность, поэтому очень важно было
реализовать семантику exactly once при операциях изменения счета. 
С прямым пополнением счета через Payment Service проблем нет, но при 
передаче заказа от OrderService с ним могут возникнуть проблемы.
По этой причине межсервисное взаимодействие построено на основе 
паттернов Transaction inbox и Transactional outbox. 

Для RabbitMQ также был добавлен слой абстракции в виде MassTransit - 
open-source программного обеспечения, упрощающего жизнь при работе
с RabbitMQ.

### Итоговый стек технологий

Api Gateway:

- Ocelot (для рутинга запросов)

Order Service:

- Swagger (для документации и тестирования)
- SQLite + EntityFrameworkCore
- RabbitMQ
- MassTransit

Payment Service:

- Swagger (для документации и тестирования)
- SQLite + EntityFrameworkCore
- RabbitMQ
- MassTransit

Для всех проектов:

- ASP.NET Core

### Разворачивание 

Из-за того, что брокер сообщений - это отдельный сервис, 
запуск проекта через multi-launch не предусмотрен. Основным способом
развернуть проект является Docker: в директории проекта лежит docker-compose
файл со всеми параметрами. При таком запуске Swagger коллекции будут
лежать по адресу http://localhost:5001/swagger/index.html для Order Service
и http://localhost:5002/swagger/index.html - для Payment Service. Маршруты
же для запросов к api через Api Gateway лежат по адресу http://localhost:8080,
конкретные маршруты будут ниже.

### Поведение программы

#### Api Gateway

Перенаправляет пользователей на другие сервисы,
возвращает им ответ от других сервисов. Реализовано
с помощью технологии ocelot - в файле ocelot.json
прописана конфигурация маршрутизации запросов. Весь обмен
информацией сервисов друг между другом и с пользователем
происходит через http запросы.

#### Order Service

- Создание заказа через POST /gateway/orders
- Просмотр заказа через GET /gateway/orders/{id}
- Просмотр всех заказов через GET /gateway/orders (тут сложная схема с
участием пагинации и параметров запроса, в swagger указаны все параметры
и всё в целом понятно)

Здесь реализован паттерн Transactional outbox - заказы складываются в 
очередь в виде событий, из которой потом их берет Payment Service. 
У каждого заказа есть статус - на момент отправки New.

#### Payment Service

- Создание счета через POST /gateway/payments
- Пополнение счета через POST /gateway/payments/{userId}/top-up
- Информация о счете через GET /gateway/payments/{id}
- Также обрабатывает заказы через брокер сообщений

Здесь реализованы оба Transactional паттерна - inbox и outbox. 
Сервис вытаскивает запросы из очереди, обрабатывает, изменяет статус
заказа на успешный или неуспешный (например, если пользователя нет или
у него недостаточно средств) и кладет заказ с доп информацией и статусом в очередь.
Order service читает из этой очереди сообщение без реализации inbox 
паттерна, так как такие запросы идемпотентны.

### Сценарий работы

Создаём счет через POST /gateway/payments по userId, дальше пополняем
его через POST /gateway/payments/{userId}/top-up. Формируем заказ 
через POST /gateway/orders, в описании заказа указано, например, что
это телефон. Дальше просматриваем баланс счета 
через GET /gateway/payments/{userId} и убеждаемся, что он
уменьшился на соответствующую сумму. 

Сам магазин может просмотреть заказы через GET /gateway/orders в удобном
формате.